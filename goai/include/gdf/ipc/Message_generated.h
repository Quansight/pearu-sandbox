// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGE_ORG_APACHE_ARROW_FLATBUF_H_
#define FLATBUFFERS_GENERATED_MESSAGE_ORG_APACHE_ARROW_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "Schema_generated.h"
#include "Tensor_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace flatbuf {

struct FieldNode;

struct RecordBatch;

struct DictionaryBatch;

struct Message;

/// ----------------------------------------------------------------------
/// The root Message type
/// This union enables us to easily send different message types without
/// redundant storage, and in the future we can easily add new message types.
///
/// Arrow implementations do not need to implement all of the message types,
/// which may include experimental metadata types. For maximum compatibility,
/// it is best to send data using RecordBatch
enum MessageHeader {
  MessageHeader_NONE = 0,
  MessageHeader_Schema = 1,
  MessageHeader_DictionaryBatch = 2,
  MessageHeader_RecordBatch = 3,
  MessageHeader_Tensor = 4,
  MessageHeader_MIN = MessageHeader_NONE,
  MessageHeader_MAX = MessageHeader_Tensor
};

inline const char **EnumNamesMessageHeader() {
  static const char *names[] = {
    "NONE",
    "Schema",
    "DictionaryBatch",
    "RecordBatch",
    "Tensor",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageHeader(MessageHeader e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageHeader()[index];
}

template<typename T> struct MessageHeaderTraits {
  static const MessageHeader enum_value = MessageHeader_NONE;
};

template<> struct MessageHeaderTraits<org::apache::arrow::flatbuf::Schema> {
  static const MessageHeader enum_value = MessageHeader_Schema;
};

template<> struct MessageHeaderTraits<DictionaryBatch> {
  static const MessageHeader enum_value = MessageHeader_DictionaryBatch;
};

template<> struct MessageHeaderTraits<RecordBatch> {
  static const MessageHeader enum_value = MessageHeader_RecordBatch;
};

template<> struct MessageHeaderTraits<org::apache::arrow::flatbuf::Tensor> {
  static const MessageHeader enum_value = MessageHeader_Tensor;
};

bool VerifyMessageHeader(flatbuffers::Verifier &verifier, const void *obj, MessageHeader type);
bool VerifyMessageHeaderVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// ----------------------------------------------------------------------
/// Data structures for describing a table row batch (a collection of
/// equal-length Arrow arrays)
/// Metadata about a field at some level of a nested type tree (but not
/// its children).
///
/// For example, a List<Int16> with values [[1, 2, 3], null, [4], [5, 6], null]
/// would have {length: 5, null_count: 2} for its List node, and {length: 6,
/// null_count: 0} for its Int16 node, as separate FieldNode structs
MANUALLY_ALIGNED_STRUCT(8) FieldNode FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t length_;
  int64_t null_count_;

 public:
  FieldNode() {
    memset(this, 0, sizeof(FieldNode));
  }
  FieldNode(const FieldNode &_o) {
    memcpy(this, &_o, sizeof(FieldNode));
  }
  FieldNode(int64_t _length, int64_t _null_count)
      : length_(flatbuffers::EndianScalar(_length)),
        null_count_(flatbuffers::EndianScalar(_null_count)) {
  }
  /// The number of value slots in the Arrow array at this level of a nested
  /// tree
  int64_t length() const {
    return flatbuffers::EndianScalar(length_);
  }
  /// The number of observed nulls. Fields with null_count == 0 may choose not
  /// to write their physical validity bitmap out as a materialized buffer,
  /// instead setting the length of the bitmap buffer to 0.
  int64_t null_count() const {
    return flatbuffers::EndianScalar(null_count_);
  }
};
STRUCT_END(FieldNode, 16);

/// A data header describing the shared memory layout of a "record" or "row"
/// batch. Some systems call this a "row batch" internally and others a "record
/// batch".
struct RecordBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LENGTH = 4,
    VT_NODES = 6,
    VT_BUFFERS = 8
  };
  /// number of records / rows. The arrays in the batch should all have this
  /// length
  int64_t length() const {
    return GetField<int64_t>(VT_LENGTH, 0);
  }
  /// Nodes correspond to the pre-ordered flattened logical schema
  const flatbuffers::Vector<const FieldNode *> *nodes() const {
    return GetPointer<const flatbuffers::Vector<const FieldNode *> *>(VT_NODES);
  }
  /// Buffers correspond to the pre-ordered flattened buffer tree
  ///
  /// The number of buffers appended to this list depends on the schema. For
  /// example, most primitive arrays will have 2 buffers, 1 for the validity
  /// bitmap and 1 for the values. For struct arrays, there will only be a
  /// single buffer for the validity (nulls) bitmap
  const flatbuffers::Vector<const org::apache::arrow::flatbuf::Buffer *> *buffers() const {
    return GetPointer<const flatbuffers::Vector<const org::apache::arrow::flatbuf::Buffer *> *>(VT_BUFFERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_LENGTH) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODES) &&
           verifier.Verify(nodes()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BUFFERS) &&
           verifier.Verify(buffers()) &&
           verifier.EndTable();
  }
};

struct RecordBatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_length(int64_t length) {
    fbb_.AddElement<int64_t>(RecordBatch::VT_LENGTH, length, 0);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<const FieldNode *>> nodes) {
    fbb_.AddOffset(RecordBatch::VT_NODES, nodes);
  }
  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<const org::apache::arrow::flatbuf::Buffer *>> buffers) {
    fbb_.AddOffset(RecordBatch::VT_BUFFERS, buffers);
  }
  RecordBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecordBatchBuilder &operator=(const RecordBatchBuilder &);
  flatbuffers::Offset<RecordBatch> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<RecordBatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecordBatch> CreateRecordBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t length = 0,
    flatbuffers::Offset<flatbuffers::Vector<const FieldNode *>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<const org::apache::arrow::flatbuf::Buffer *>> buffers = 0) {
  RecordBatchBuilder builder_(_fbb);
  builder_.add_length(length);
  builder_.add_buffers(buffers);
  builder_.add_nodes(nodes);
  return builder_.Finish();
}

inline flatbuffers::Offset<RecordBatch> CreateRecordBatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t length = 0,
    const std::vector<const FieldNode *> *nodes = nullptr,
    const std::vector<const org::apache::arrow::flatbuf::Buffer *> *buffers = nullptr) {
  return org::apache::arrow::flatbuf::CreateRecordBatch(
      _fbb,
      length,
      nodes ? _fbb.CreateVector<const FieldNode *>(*nodes) : 0,
      buffers ? _fbb.CreateVector<const org::apache::arrow::flatbuf::Buffer *>(*buffers) : 0);
}

/// ----------------------------------------------------------------------
/// For sending dictionary encoding information. Any Field can be
/// dictionary-encoded, but in this case none of its children may be
/// dictionary-encoded.
/// There is one vector / column per dictionary
///
struct DictionaryBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_DATA = 6
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  const RecordBatch *data() const {
    return GetPointer<const RecordBatch *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.VerifyTable(data()) &&
           verifier.EndTable();
  }
};

struct DictionaryBatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(DictionaryBatch::VT_ID, id, 0);
  }
  void add_data(flatbuffers::Offset<RecordBatch> data) {
    fbb_.AddOffset(DictionaryBatch::VT_DATA, data);
  }
  DictionaryBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DictionaryBatchBuilder &operator=(const DictionaryBatchBuilder &);
  flatbuffers::Offset<DictionaryBatch> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<DictionaryBatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<DictionaryBatch> CreateDictionaryBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    flatbuffers::Offset<RecordBatch> data = 0) {
  DictionaryBatchBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_data(data);
  return builder_.Finish();
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_HEADER_TYPE = 6,
    VT_HEADER = 8,
    VT_BODYLENGTH = 10
  };
  org::apache::arrow::flatbuf::MetadataVersion version() const {
    return static_cast<org::apache::arrow::flatbuf::MetadataVersion>(GetField<int16_t>(VT_VERSION, 0));
  }
  MessageHeader header_type() const {
    return static_cast<MessageHeader>(GetField<uint8_t>(VT_HEADER_TYPE, 0));
  }
  const void *header() const {
    return GetPointer<const void *>(VT_HEADER);
  }
  int64_t bodyLength() const {
    return GetField<int64_t>(VT_BODYLENGTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_HEADER_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HEADER) &&
           VerifyMessageHeader(verifier, header(), header_type()) &&
           VerifyField<int64_t>(verifier, VT_BODYLENGTH) &&
           verifier.EndTable();
  }
};

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(org::apache::arrow::flatbuf::MetadataVersion version) {
    fbb_.AddElement<int16_t>(Message::VT_VERSION, static_cast<int16_t>(version), 0);
  }
  void add_header_type(MessageHeader header_type) {
    fbb_.AddElement<uint8_t>(Message::VT_HEADER_TYPE, static_cast<uint8_t>(header_type), 0);
  }
  void add_header(flatbuffers::Offset<void> header) {
    fbb_.AddOffset(Message::VT_HEADER, header);
  }
  void add_bodyLength(int64_t bodyLength) {
    fbb_.AddElement<int64_t>(Message::VT_BODYLENGTH, bodyLength, 0);
  }
  MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::flatbuf::MetadataVersion version = org::apache::arrow::flatbuf::MetadataVersion_V1,
    MessageHeader header_type = MessageHeader_NONE,
    flatbuffers::Offset<void> header = 0,
    int64_t bodyLength = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_bodyLength(bodyLength);
  builder_.add_header(header);
  builder_.add_version(version);
  builder_.add_header_type(header_type);
  return builder_.Finish();
}

inline bool VerifyMessageHeader(flatbuffers::Verifier &verifier, const void *obj, MessageHeader type) {
  switch (type) {
    case MessageHeader_NONE: {
      return true;
    }
    case MessageHeader_Schema: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Schema *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageHeader_DictionaryBatch: {
      auto ptr = reinterpret_cast<const DictionaryBatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageHeader_RecordBatch: {
      auto ptr = reinterpret_cast<const RecordBatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageHeader_Tensor: {
      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Tensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageHeaderVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageHeader(
        verifier,  values->Get(i), types->GetEnum<MessageHeader>(i))) {
      return false;
    }
  }
  return true;
}

inline const org::apache::arrow::flatbuf::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::flatbuf::Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::flatbuf::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Message> root) {
  fbb.Finish(root);
}

}  // namespace flatbuf
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_MESSAGE_ORG_APACHE_ARROW_FLATBUF_H_
